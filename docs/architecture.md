# æ¶æ„è§£æ

## ç³»ç»Ÿæ¶æ„æ¦‚è¿°

å¾®ä¿¡è¯»ä¹¦å¯¼å‡ºå·¥å…·é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼Œæ ¸å¿ƒæ¶æ„åŸºäºå¼‚æ­¥äº‹ä»¶é©±åŠ¨æ¨¡å‹ã€‚æ•´ä¸ªç³»ç»Ÿåˆ†ä¸ºå››ä¸ªä¸»è¦å±‚æ¬¡ï¼šå‘½ä»¤è¡Œæ¥å£å±‚ã€ä¸šåŠ¡é€»è¾‘å±‚ã€æµè§ˆå™¨æ§åˆ¶å±‚å’Œæ ¼å¼è½¬æ¢å±‚ã€‚

### æ¶æ„å±‚æ¬¡å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   å‘½ä»¤è¡Œæ¥å£å±‚ (CLI Layer)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å‚æ•°è§£æ â”‚ é…ç½®ç®¡ç† â”‚ æ—¥å¿—è®°å½• â”‚ é”™è¯¯å¤„ç† â”‚ ç”¨æˆ·äº¤äº’          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ä¸šåŠ¡é€»è¾‘å±‚ (Business Layer)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å¯¼å‡ºæµç¨‹æ§åˆ¶ â”‚ ç« èŠ‚ç®¡ç† â”‚ ç¼“å­˜ç®¡ç† â”‚ çŠ¶æ€ç®¡ç† â”‚ è´¨é‡æ§åˆ¶      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  æµè§ˆå™¨æ§åˆ¶å±‚ (Browser Layer)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ é¡µé¢å¯¼èˆª â”‚ Canvas Hook â”‚ å†…å®¹æ‹¦æˆª â”‚ ç™»å½•ç®¡ç† â”‚ åæ£€æµ‹æœºåˆ¶    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   æ ¼å¼è½¬æ¢å±‚ (Format Layer)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Markdownå¤„ç† â”‚ EPUBç”Ÿæˆ â”‚ PDFæ¸²æŸ“ â”‚ MOBIè½¬æ¢ â”‚ æ ·å¼åº”ç”¨      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## æ ¸å¿ƒæ¨¡å—è¯¦è§£

### 1. å‘½ä»¤è¡Œæ¥å£æ¨¡å— (`__main__.py`)

#### åŠŸèƒ½èŒè´£
- å‘½ä»¤è¡Œå‚æ•°è§£æå’ŒéªŒè¯
- é…ç½®æ–‡ä»¶çš„åŠ è½½å’Œç®¡ç†
- æ—¥å¿—ç³»ç»Ÿçš„åˆå§‹åŒ–å’Œé…ç½®
- é”™è¯¯å¤„ç†å’Œç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯å±•ç¤º
- å¼‚æ­¥äº‹ä»¶å¾ªç¯çš„ç®¡ç†

#### å…³é”®ä»£ç ç»“æ„

```python
class CommandLineInterface:
    def __init__(self):
        self.parser = self._create_parser()
        self.config = self._load_config()
    
    def _create_parser(self):
        """åˆ›å»ºå‘½ä»¤è¡Œå‚æ•°è§£æå™¨"""
        parser = argparse.ArgumentParser(
            prog="weread-exporter",
            description="å¾®ä¿¡è¯»ä¹¦ä¹¦ç±å¯¼å‡ºå·¥å…·"
        )
        
        # å¿…éœ€å‚æ•°
        parser.add_argument("-b", "--book-id", required=True,
                           help="ä¹¦ç±ID")
        
        # å¯é€‰å‚æ•°
        parser.add_argument("-o", "--output-format", 
                           action="append", choices=["epub", "pdf", "mobi"])
        
        return parser
    
    async def run(self):
        """ä¸»è¿è¡Œé€»è¾‘"""
        try:
            # å‚æ•°éªŒè¯
            self._validate_args()
            
            # åˆ›å»ºå¯¼å‡ºå™¨å®ä¾‹
            exporter = WeReadExporter(self.args.book_id)
            
            # æ‰§è¡Œå¯¼å‡ºæµç¨‹
            await exporter.export()
            
        except Exception as e:
            self._handle_error(e)
```

#### è®¾è®¡æ¨¡å¼åº”ç”¨
- **å‘½ä»¤æ¨¡å¼**: å°è£…å¯¼å‡ºæ“ä½œçš„å…·ä½“å®ç°
- **å·¥å‚æ¨¡å¼**: æ ¹æ®å‚æ•°åˆ›å»ºä¸åŒçš„å¯¼å‡ºå™¨å®ä¾‹
- **ç­–ç•¥æ¨¡å¼**: æ”¯æŒå¤šç§è¾“å‡ºæ ¼å¼çš„çµæ´»åˆ‡æ¢

### 2. ç½‘é¡µæ§åˆ¶æ¨¡å— (`webpage.py`)

#### åŠŸèƒ½èŒè´£
- æµè§ˆå™¨å®ä¾‹çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
- é¡µé¢å¯¼èˆªå’Œå†…å®¹åŠ è½½æ§åˆ¶
- Canvas Hookè„šæœ¬çš„æ³¨å…¥å’Œæ‰§è¡Œ
- ç½‘ç»œè¯·æ±‚çš„æ‹¦æˆªå’Œæ¨¡æ‹Ÿ
- åæ£€æµ‹æœºåˆ¶çš„å®ç°

#### æ ¸å¿ƒå®ç°åŸç†

```python
class WeReadWebPage:
    def __init__(self, book_id):
        self.book_id = book_id
        self.browser = None
        self.page = None
        self.hook_script = self._load_hook_script()
    
    async def launch(self, headless=False):
        """å¯åŠ¨æµè§ˆå™¨å¹¶é…ç½®åæ£€æµ‹æœºåˆ¶"""
        # æµè§ˆå™¨å¯åŠ¨å‚æ•°
        launch_args = [
            "--no-first-run",
            "--remote-allow-origins=*",
            "--disable-web-security",
            "--disable-features=VizDisplayCompositor"
        ]
        
        if headless:
            launch_args.append("--headless")
        
        self.browser = await pyppeteer.launch({
            'args': launch_args,
            'headless': headless
        })
        
        self.page = await self.browser.newPage()
        
        # è®¾ç½®åæ£€æµ‹æœºåˆ¶
        await self._setup_anti_detection()
        
        # æ³¨å…¥Hookè„šæœ¬
        await self._inject_hook_script()
    
    async def _setup_anti_detection(self):
        """é…ç½®åæ£€æµ‹æœºåˆ¶"""
        # éšè—webdriverå±æ€§
        await self.page.evaluateOnNewDocument('''
            () => {
                Object.defineProperty(navigator, 'webdriver', {
                    get: () => undefined
                })
                
                // ä¿®æ”¹æ’ä»¶åˆ—è¡¨
                Object.defineProperty(navigator, 'plugins', {
                    get: () => [1, 2, 3, 4, 5]
                })
                
                // ä¿®æ”¹è¯­è¨€è®¾ç½®
                Object.defineProperty(navigator, 'languages', {
                    get: () => ['zh-CN', 'zh', 'en']
                })
            }
        ''')
        
        # è®¾ç½®ç”¨æˆ·ä»£ç†
        await self.page.setUserAgent(
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) '
            'AppleWebKit/537.36 (KHTML, like Gecko) '
            'Chrome/91.0.4472.124 Safari/537.36'
        )
```

#### ç½‘ç»œè¯·æ±‚æ‹¦æˆªæœºåˆ¶

```python
async def _setup_request_interception(self):
    """è®¾ç½®è¯·æ±‚æ‹¦æˆª"""
    await self.page.setRequestInterception(True)
    
    async def intercept_request(request):
        # æ‹¦æˆªCanvasç›¸å…³è„šæœ¬
        if "/web/1.392ec47a.js" in request.url:
            await request.respond({
                'status': 200,
                'contentType': 'application/javascript',
                'body': self.hook_script
            })
            return
        
        # æ‹¦æˆªAPIè¯·æ±‚å¹¶æ¨¡æ‹Ÿå“åº”
        if "/web/book/read" in request.url:
            await request.respond({
                'status': 200,
                'contentType': 'application/json',
                'body': '{"succ":1,"synckey":12345678}'
            })
            return
        
        # å…è®¸å…¶ä»–è¯·æ±‚ç»§ç»­
        await request.continue_()
    
    self.page.on('request', intercept_request)
```

### 3. Canvas Hookæ¨¡å— (`hook.js`)

#### æŠ€æœ¯åŸç†

Canvas Hookæ˜¯é¡¹ç›®çš„æ ¸å¿ƒæŠ€æœ¯ï¼Œé€šè¿‡JavaScript Proxyå¯¹è±¡æ‹¦æˆªCanvasçš„ç»˜åˆ¶æ“ä½œï¼š

```javascript
// æ‹¦æˆªCanvasçš„getContextæ–¹æ³•
const originalGetContext = HTMLCanvasElement.prototype.getContext;

HTMLCanvasElement.prototype.getContext = function(type, options) {
    const ctx = originalGetContext.call(this, type, options);
    
    if (type === '2d') {
        // åˆ›å»ºä»£ç†æ‹¦æˆªCanvasæ“ä½œ
        return new Proxy(ctx, {
            get(target, property) {
                const value = target[property];
                
                if (typeof value === 'function') {
                    // æ‹¦æˆªæ–¹æ³•è°ƒç”¨
                    return function(...args) {
                        return interceptCanvasOperation(
                            property, target, args, this
                        );
                    };
                }
                
                return value;
            },
            
            set(target, property, value) {
                // æ‹¦æˆªå±æ€§è®¾ç½®
                if (property === 'font') {
                    analyzeFont(value);
                } else if (property === 'fillStyle') {
                    analyzeColor(value);
                }
                
                target[property] = value;
                return true;
            }
        });
    }
    
    return ctx;
};
```

#### æ–‡æœ¬è¯†åˆ«ç®—æ³•

```javascript
class TextAnalyzer {
    constructor() {
        this.markdown = '';
        this.currentStyle = {
            fontSize: 16,
            fontColor: '#000000',
            isBold: false,
            isItalic: false
        };
        this.contextStack = [];
    }
    
    analyzeFillText(text, x, y) {
        const formattedText = this.formatText(text);
        
        // æ ¹æ®ä½ç½®å’Œæ ·å¼åˆ¤æ–­æ–‡æœ¬ç»“æ„
        if (this.isTitle()) {
            this.markdown += `\n\n# ${formattedText}\n`;
        } else if (this.isHighlight()) {
            this.markdown += `\`${formattedText}\``;
        } else if (this.isCodeBlock()) {
            this.markdown += `\n\`\`\`\n${formattedText}\n\`\`\`\n`;
        } else {
            this.markdown += formattedText;
        }
    }
    
    isTitle() {
        return this.currentStyle.fontSize >= 24;
    }
    
    isHighlight() {
        return this.currentStyle.fontColor !== '#000000';
    }
    
    isCodeBlock() {
        // é€šè¿‡å­—ä½“æ—å’ŒèƒŒæ™¯è‰²è¯†åˆ«ä»£ç å—
        return this.currentStyle.fontFamily.includes('monospace') ||
               this.contextStack.includes('code');
    }
}
```

### 4. å¯¼å‡ºå¤„ç†æ¨¡å— (`export.py`)

#### å¯¼å‡ºæµç¨‹æ§åˆ¶

```python
class WeReadExporter:
    def __init__(self, page, save_path):
        self.page = page
        self.save_path = save_path
        self.meta_data = {}
        self.chapters = []
    
    async def export_markdown(self, load_timeout=60, load_interval=30):
        """å¯¼å‡ºMarkdownæ ¼å¼å†…å®¹"""
        
        # 1. è·å–ä¹¦ç±å…ƒæ•°æ®
        await self._fetch_metadata()
        
        # 2. è·å–ç« èŠ‚åˆ—è¡¨
        chapters = await self._get_chapters()
        
        # 3. å¹¶å‘å¤„ç†ç« èŠ‚
        tasks = []
        for chapter in chapters:
            task = self._process_chapter(chapter, load_timeout, load_interval)
            tasks.append(task)
        
        # ç­‰å¾…æ‰€æœ‰ç« èŠ‚å®Œæˆ
        await asyncio.gather(*tasks)
        
        # 4. ç”ŸæˆMarkdownæ–‡ä»¶
        await self._generate_markdown()
    
    async def _process_chapter(self, chapter, timeout, interval):
        """å¤„ç†å•ä¸ªç« èŠ‚"""
        
        # å¯¼èˆªåˆ°ç« èŠ‚é¡µé¢
        await self.page.goto(chapter['url'])
        
        # ç­‰å¾…å†…å®¹åŠ è½½
        await asyncio.sleep(interval)
        
        # è·å–Canvasæ¸²æŸ“å†…å®¹
        content = await self.page.evaluate('''
            () => {
                return window.canvasInterceptor.getMarkdown();
            }
        ''')
        
        # å¤„ç†å›¾ç‰‡ä¸‹è½½
        await self._download_images(content)
        
        # ä¿å­˜ç« èŠ‚å†…å®¹
        chapter['content'] = content
        self.chapters.append(chapter)
```

#### æ ¼å¼è½¬æ¢å¼•æ“

```python
class FormatConverter:
    def __init__(self, meta_data, chapters):
        self.meta_data = meta_data
        self.chapters = chapters
    
    async def to_epub(self, output_path, css_file=None):
        """è½¬æ¢ä¸ºEPUBæ ¼å¼"""
        book = epub.EpubBook()
        
        # è®¾ç½®ä¹¦ç±å…ƒæ•°æ®
        book.set_title(self.meta_data['title'])
        book.set_language('zh-CN')
        book.add_author(self.meta_data['author'])
        
        # åˆ›å»ºç« èŠ‚
        spine = ['nav']
        for i, chapter in enumerate(self.chapters):
            epub_chapter = self._create_epub_chapter(chapter, i)
            book.add_item(epub_chapter)
            spine.append(epub_chapter)
        
        # è®¾ç½®ä¹¦ç±ç»“æ„
        book.spine = spine
        book.toc = self._create_toc()
        
        # ç”ŸæˆEPUBæ–‡ä»¶
        epub.write_epub(output_path, book, {})
    
    async def to_pdf(self, output_path, css_file=None):
        """è½¬æ¢ä¸ºPDFæ ¼å¼"""
        # ç”ŸæˆHTMLå†…å®¹
        html_content = self._generate_html()
        
        # åº”ç”¨CSSæ ·å¼
        if css_file:
            css_content = self._load_css(css_file)
        else:
            css_content = self._default_css()
        
        # ä½¿ç”¨WeasyPrintç”ŸæˆPDF
        html = HTML(string=html_content)
        html.write_pdf(output_path, stylesheets=[CSS(string=css_content)])
```

## å¼‚æ­¥æ¶æ„è®¾è®¡

### äº‹ä»¶å¾ªç¯ç®¡ç†

é¡¹ç›®é‡‡ç”¨asyncioå®ç°å…¨å¼‚æ­¥æ¶æ„ï¼š

```python
class AsyncExportManager:
    def __init__(self, max_concurrent=3):
        self.semaphore = asyncio.Semaphore(max_concurrent)
        self.tasks = []
    
    async def export_books(self, book_ids, formats):
        """å¹¶å‘å¯¼å‡ºå¤šæœ¬ä¹¦ç±"""
        
        # åˆ›å»ºå¯¼å‡ºä»»åŠ¡
        for book_id in book_ids:
            task = asyncio.create_task(
                self._export_single_book(book_id, formats)
            )
            self.tasks.append(task)
        
        # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        results = await asyncio.gather(*self.tasks, return_exceptions=True)
        
        # å¤„ç†ç»“æœ
        return self._process_results(results)
    
    async def _export_single_book(self, book_id, formats):
        """å¯¼å‡ºå•æœ¬ä¹¦ç±"""
        async with self.semaphore:
            # é™åˆ¶å¹¶å‘æ•°é‡
            exporter = WeReadExporter(book_id)
            return await exporter.export(formats)
```

### èµ„æºç®¡ç†

```python
class ResourceManager:
    def __init__(self):
        self.browser_pool = BrowserPool(max_browsers=5)
        self.cache_manager = CacheManager()
        self.memory_monitor = MemoryMonitor()
    
    async def get_browser(self):
        """ä»æ± ä¸­è·å–æµè§ˆå™¨å®ä¾‹"""
        return await self.browser_pool.acquire()
    
    async def release_browser(self, browser):
        """é‡Šæ”¾æµè§ˆå™¨å®ä¾‹"""
        await self.browser_pool.release(browser)
    
    async def cleanup(self):
        """æ¸…ç†èµ„æº"""
        await self.browser_pool.cleanup()
        await self.cache_manager.cleanup()
```

## ç¼“å­˜ç³»ç»Ÿè®¾è®¡

### å¤šçº§ç¼“å­˜æ¶æ„

```python
class MultiLevelCache:
    def __init__(self):
        self.memory_cache = LRUCache(maxsize=1000)
        self.disk_cache = DiskCache(cache_dir='.weread/cache')
        self.network_cache = NetworkCache()
    
    async def get(self, key, fetch_func):
        """è·å–ç¼“å­˜æ•°æ®"""
        
        # 1. æ£€æŸ¥å†…å­˜ç¼“å­˜
        if key in self.memory_cache:
            return self.memory_cache[key]
        
        # 2. æ£€æŸ¥ç£ç›˜ç¼“å­˜
        cached = await self.disk_cache.get(key)
        if cached:
            self.memory_cache[key] = cached
            return cached
        
        # 3. ä»ç½‘ç»œè·å–
        data = await fetch_func()
        
        # 4. æ›´æ–°ç¼“å­˜
        self.memory_cache[key] = data
        await self.disk_cache.set(key, data)
        
        return data
```

### æ™ºèƒ½ç¼“å­˜ç­–ç•¥

```python
class SmartCacheStrategy:
    def should_cache(self, url, data):
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥ç¼“å­˜"""
        
        # æ ¹æ®å†…å®¹ç±»å‹å†³å®šç¼“å­˜ç­–ç•¥
        content_type = self._get_content_type(url, data)
        
        if content_type == 'text':
            return len(data) < 100 * 1024  # æ–‡æœ¬å°äº100KB
        elif content_type == 'image':
            return len(data) < 5 * 1024 * 1024  # å›¾ç‰‡å°äº5MB
        elif content_type == 'script':
            return True  # è„šæœ¬æ€»æ˜¯ç¼“å­˜
        
        return False
```

## é”™è¯¯å¤„ç†å’Œæ¢å¤

### é”™è¯¯åˆ†ç±»å’Œå¤„ç†

```python
class ErrorHandler:
    def __init__(self):
        self.retry_strategies = {
            'network_error': ExponentialBackoffRetry(),
            'browser_crash': BrowserRestartRetry(),
            'content_parsing': ContentReprocessRetry()
        }
    
    async def handle_error(self, error, context):
        """å¤„ç†é”™è¯¯"""
        error_type = self._classify_error(error)
        
        if error_type in self.retry_strategies:
            strategy = self.retry_strategies[error_type]
            return await strategy.retry(context)
        else:
            # æ— æ³•æ¢å¤çš„é”™è¯¯
            raise error
```

### æ–­ç‚¹ç»­ä¼ æœºåˆ¶

```python
class ResumeManager:
    def __init__(self, checkpoint_file):
        self.checkpoint_file = checkpoint_file
        self.checkpoints = self._load_checkpoints()
    
    async def save_checkpoint(self, book_id, progress):
        """ä¿å­˜æ£€æŸ¥ç‚¹"""
        self.checkpoints[book_id] = {
            'progress': progress,
            'timestamp': time.time()
        }
        await self._save_checkpoints()
    
    async def resume_export(self, book_id):
        """æ¢å¤å¯¼å‡º"""
        if book_id in self.checkpoints:
            checkpoint = self.checkpoints[book_id]
            return checkpoint['progress']
        return None
```

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å†…å­˜ä¼˜åŒ–

```python
class MemoryOptimizer:
    def __init__(self, memory_limit=512):  # 512MB
        self.memory_limit = memory_limit * 1024 * 1024
    
    async def optimize_memory(self):
        """ä¼˜åŒ–å†…å­˜ä½¿ç”¨"""
        current_memory = self._get_memory_usage()
        
        if current_memory > self.memory_limit:
            # è§¦å‘åƒåœ¾å›æ”¶
            import gc
            gc.collect()
            
            # æ¸…ç†ç¼“å­˜
            await self._clear_caches()
            
            # é‡å¯æµè§ˆå™¨å®ä¾‹
            await self._restart_browsers()
```

### 2. ç½‘ç»œä¼˜åŒ–

```python
class NetworkOptimizer:
    def __init__(self):
        self.connection_pool = ConnectionPool()
        self.request_throttler = RequestThrottler()
    
    async def optimize_requests(self, requests):
        """ä¼˜åŒ–ç½‘ç»œè¯·æ±‚"""
        # åˆå¹¶é‡å¤è¯·æ±‚
        merged = self._merge_requests(requests)
        
        # åº”ç”¨é™æµ
        throttled = await self.request_throttler.throttle(merged)
        
        # ä½¿ç”¨è¿æ¥æ± 
        return await self.connection_pool.execute(throttled)
```

## å®‰å…¨è€ƒè™‘

### 1. æ•°æ®å®‰å…¨

```python
class SecurityManager:
    def __init__(self):
        self.encryption = AESEncryption()
        self.sanitizer = HTMLSanitizer()
    
    async def secure_data(self, data):
        """ä¿æŠ¤æ•æ„Ÿæ•°æ®"""
        # åŠ å¯†å­˜å‚¨
        encrypted = self.encryption.encrypt(data)
        
        # æ¸…ç†HTMLå†…å®¹
        sanitized = self.sanitizer.sanitize(encrypted)
        
        return sanitized
```

### 2. éšç§ä¿æŠ¤

```python
class PrivacyProtector:
    def __init__(self):
        self.anonymizer = DataAnonymizer()
    
    async def protect_privacy(self, user_data):
        """ä¿æŠ¤ç”¨æˆ·éšç§"""
        # åŒ¿ååŒ–å¤„ç†
        anonymized = self.anonymizer.anonymize(user_data)
        
        # åˆ é™¤æ•æ„Ÿä¿¡æ¯
        cleaned = self._remove_sensitive_info(anonymized)
        
        return cleaned
```

## æ‰©å±•æ€§è®¾è®¡

### æ’ä»¶ç³»ç»Ÿæ¶æ„

```python
class PluginSystem:
    def __init__(self):
        self.plugins = {}
        self.hooks = {}
    
    def register_plugin(self, name, plugin):
        """æ³¨å†Œæ’ä»¶"""
        self.plugins[name] = plugin
        
        # æ³¨å†Œæ’ä»¶é’©å­
        for hook_name in plugin.get_hooks():
            if hook_name not in self.hooks:
                self.hooks[hook_name] = []
            self.hooks[hook_name].append(plugin)
    
    async def execute_hook(self, hook_name, data):
        """æ‰§è¡Œé’©å­"""
        if hook_name in self.hooks:
            for plugin in self.hooks[hook_name]:
                data = await plugin.execute_hook(hook_name, data)
        return data
```

## ç›‘æ§å’Œæ—¥å¿—

### æ€§èƒ½ç›‘æ§

```python
class PerformanceMonitor:
    def __init__(self):
        self.metrics = {}
        self.start_time = time.time()
    
    async def track_metric(self, name, value):
        """è·Ÿè¸ªæ€§èƒ½æŒ‡æ ‡"""
        if name not in self.metrics:
            self.metrics[name] = []
        self.metrics[name].append({
            'value': value,
            'timestamp': time.time()
        })
    
    async def generate_report(self):
        """ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š"""
        return {
            'total_time': time.time() - self.start_time,
            'metrics': self.metrics,
            'summary': self._generate_summary()
        }
```

---

**æ¶æ„è§£æåˆ°æ­¤ç»“æŸã€‚** è¿™ä¸ªæ¶æ„è®¾è®¡ç¡®ä¿äº†å·¥å…·çš„é«˜æ€§èƒ½ã€å¯æ‰©å±•æ€§å’Œç¨³å®šæ€§ã€‚ç»§ç»­é˜…è¯»[APIæ–‡æ¡£](api.md)äº†è§£å…·ä½“çš„æ¥å£ä½¿ç”¨æ–¹æ³•ã€‚ ğŸ—ï¸